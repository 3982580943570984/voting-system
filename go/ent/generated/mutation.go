// Code generated by ent, DO NOT EDIT.

package generated

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"
	"voting-system/ent/generated/candidate"
	"voting-system/ent/generated/comment"
	"voting-system/ent/generated/election"
	"voting-system/ent/generated/electionsettings"
	"voting-system/ent/generated/predicate"
	"voting-system/ent/generated/profile"
	"voting-system/ent/generated/tag"
	"voting-system/ent/generated/user"
	"voting-system/ent/generated/vote"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCandidate        = "Candidate"
	TypeComment          = "Comment"
	TypeElection         = "Election"
	TypeElectionSettings = "ElectionSettings"
	TypeProfile          = "Profile"
	TypeTag              = "Tag"
	TypeUser             = "User"
	TypeVote             = "Vote"
)

// CandidateMutation represents an operation that mutates the Candidate nodes in the graph.
type CandidateMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	name            *string
	description     *string
	photo_url       *string
	votes_count     *int
	addvotes_count  *int
	clearedFields   map[string]struct{}
	election        *int
	clearedelection bool
	votes           map[int]struct{}
	removedvotes    map[int]struct{}
	clearedvotes    bool
	done            bool
	oldValue        func(context.Context) (*Candidate, error)
	predicates      []predicate.Candidate
}

var _ ent.Mutation = (*CandidateMutation)(nil)

// candidateOption allows management of the mutation configuration using functional options.
type candidateOption func(*CandidateMutation)

// newCandidateMutation creates new mutation for the Candidate entity.
func newCandidateMutation(c config, op Op, opts ...candidateOption) *CandidateMutation {
	m := &CandidateMutation{
		config:        c,
		op:            op,
		typ:           TypeCandidate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCandidateID sets the ID field of the mutation.
func withCandidateID(id int) candidateOption {
	return func(m *CandidateMutation) {
		var (
			err   error
			once  sync.Once
			value *Candidate
		)
		m.oldValue = func(ctx context.Context) (*Candidate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Candidate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCandidate sets the old Candidate of the mutation.
func withCandidate(node *Candidate) candidateOption {
	return func(m *CandidateMutation) {
		m.oldValue = func(context.Context) (*Candidate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CandidateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CandidateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CandidateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CandidateMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Candidate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CandidateMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CandidateMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CandidateMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CandidateMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CandidateMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CandidateMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetName sets the "name" field.
func (m *CandidateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CandidateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CandidateMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *CandidateMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CandidateMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *CandidateMutation) ResetDescription() {
	m.description = nil
}

// SetPhotoURL sets the "photo_url" field.
func (m *CandidateMutation) SetPhotoURL(s string) {
	m.photo_url = &s
}

// PhotoURL returns the value of the "photo_url" field in the mutation.
func (m *CandidateMutation) PhotoURL() (r string, exists bool) {
	v := m.photo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoURL returns the old "photo_url" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldPhotoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoURL: %w", err)
	}
	return oldValue.PhotoURL, nil
}

// ClearPhotoURL clears the value of the "photo_url" field.
func (m *CandidateMutation) ClearPhotoURL() {
	m.photo_url = nil
	m.clearedFields[candidate.FieldPhotoURL] = struct{}{}
}

// PhotoURLCleared returns if the "photo_url" field was cleared in this mutation.
func (m *CandidateMutation) PhotoURLCleared() bool {
	_, ok := m.clearedFields[candidate.FieldPhotoURL]
	return ok
}

// ResetPhotoURL resets all changes to the "photo_url" field.
func (m *CandidateMutation) ResetPhotoURL() {
	m.photo_url = nil
	delete(m.clearedFields, candidate.FieldPhotoURL)
}

// SetVotesCount sets the "votes_count" field.
func (m *CandidateMutation) SetVotesCount(i int) {
	m.votes_count = &i
	m.addvotes_count = nil
}

// VotesCount returns the value of the "votes_count" field in the mutation.
func (m *CandidateMutation) VotesCount() (r int, exists bool) {
	v := m.votes_count
	if v == nil {
		return
	}
	return *v, true
}

// OldVotesCount returns the old "votes_count" field's value of the Candidate entity.
// If the Candidate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CandidateMutation) OldVotesCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVotesCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVotesCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVotesCount: %w", err)
	}
	return oldValue.VotesCount, nil
}

// AddVotesCount adds i to the "votes_count" field.
func (m *CandidateMutation) AddVotesCount(i int) {
	if m.addvotes_count != nil {
		*m.addvotes_count += i
	} else {
		m.addvotes_count = &i
	}
}

// AddedVotesCount returns the value that was added to the "votes_count" field in this mutation.
func (m *CandidateMutation) AddedVotesCount() (r int, exists bool) {
	v := m.addvotes_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetVotesCount resets all changes to the "votes_count" field.
func (m *CandidateMutation) ResetVotesCount() {
	m.votes_count = nil
	m.addvotes_count = nil
}

// SetElectionID sets the "election" edge to the Election entity by id.
func (m *CandidateMutation) SetElectionID(id int) {
	m.election = &id
}

// ClearElection clears the "election" edge to the Election entity.
func (m *CandidateMutation) ClearElection() {
	m.clearedelection = true
}

// ElectionCleared reports if the "election" edge to the Election entity was cleared.
func (m *CandidateMutation) ElectionCleared() bool {
	return m.clearedelection
}

// ElectionID returns the "election" edge ID in the mutation.
func (m *CandidateMutation) ElectionID() (id int, exists bool) {
	if m.election != nil {
		return *m.election, true
	}
	return
}

// ElectionIDs returns the "election" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ElectionID instead. It exists only for internal usage by the builders.
func (m *CandidateMutation) ElectionIDs() (ids []int) {
	if id := m.election; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetElection resets all changes to the "election" edge.
func (m *CandidateMutation) ResetElection() {
	m.election = nil
	m.clearedelection = false
}

// AddVoteIDs adds the "votes" edge to the Vote entity by ids.
func (m *CandidateMutation) AddVoteIDs(ids ...int) {
	if m.votes == nil {
		m.votes = make(map[int]struct{})
	}
	for i := range ids {
		m.votes[ids[i]] = struct{}{}
	}
}

// ClearVotes clears the "votes" edge to the Vote entity.
func (m *CandidateMutation) ClearVotes() {
	m.clearedvotes = true
}

// VotesCleared reports if the "votes" edge to the Vote entity was cleared.
func (m *CandidateMutation) VotesCleared() bool {
	return m.clearedvotes
}

// RemoveVoteIDs removes the "votes" edge to the Vote entity by IDs.
func (m *CandidateMutation) RemoveVoteIDs(ids ...int) {
	if m.removedvotes == nil {
		m.removedvotes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.votes, ids[i])
		m.removedvotes[ids[i]] = struct{}{}
	}
}

// RemovedVotes returns the removed IDs of the "votes" edge to the Vote entity.
func (m *CandidateMutation) RemovedVotesIDs() (ids []int) {
	for id := range m.removedvotes {
		ids = append(ids, id)
	}
	return
}

// VotesIDs returns the "votes" edge IDs in the mutation.
func (m *CandidateMutation) VotesIDs() (ids []int) {
	for id := range m.votes {
		ids = append(ids, id)
	}
	return
}

// ResetVotes resets all changes to the "votes" edge.
func (m *CandidateMutation) ResetVotes() {
	m.votes = nil
	m.clearedvotes = false
	m.removedvotes = nil
}

// Where appends a list predicates to the CandidateMutation builder.
func (m *CandidateMutation) Where(ps ...predicate.Candidate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CandidateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CandidateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Candidate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CandidateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CandidateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Candidate).
func (m *CandidateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CandidateMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, candidate.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, candidate.FieldUpdateTime)
	}
	if m.name != nil {
		fields = append(fields, candidate.FieldName)
	}
	if m.description != nil {
		fields = append(fields, candidate.FieldDescription)
	}
	if m.photo_url != nil {
		fields = append(fields, candidate.FieldPhotoURL)
	}
	if m.votes_count != nil {
		fields = append(fields, candidate.FieldVotesCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CandidateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case candidate.FieldCreateTime:
		return m.CreateTime()
	case candidate.FieldUpdateTime:
		return m.UpdateTime()
	case candidate.FieldName:
		return m.Name()
	case candidate.FieldDescription:
		return m.Description()
	case candidate.FieldPhotoURL:
		return m.PhotoURL()
	case candidate.FieldVotesCount:
		return m.VotesCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CandidateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case candidate.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case candidate.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case candidate.FieldName:
		return m.OldName(ctx)
	case candidate.FieldDescription:
		return m.OldDescription(ctx)
	case candidate.FieldPhotoURL:
		return m.OldPhotoURL(ctx)
	case candidate.FieldVotesCount:
		return m.OldVotesCount(ctx)
	}
	return nil, fmt.Errorf("unknown Candidate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case candidate.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case candidate.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case candidate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case candidate.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case candidate.FieldPhotoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoURL(v)
		return nil
	case candidate.FieldVotesCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVotesCount(v)
		return nil
	}
	return fmt.Errorf("unknown Candidate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CandidateMutation) AddedFields() []string {
	var fields []string
	if m.addvotes_count != nil {
		fields = append(fields, candidate.FieldVotesCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CandidateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case candidate.FieldVotesCount:
		return m.AddedVotesCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CandidateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case candidate.FieldVotesCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVotesCount(v)
		return nil
	}
	return fmt.Errorf("unknown Candidate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CandidateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(candidate.FieldPhotoURL) {
		fields = append(fields, candidate.FieldPhotoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CandidateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CandidateMutation) ClearField(name string) error {
	switch name {
	case candidate.FieldPhotoURL:
		m.ClearPhotoURL()
		return nil
	}
	return fmt.Errorf("unknown Candidate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CandidateMutation) ResetField(name string) error {
	switch name {
	case candidate.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case candidate.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case candidate.FieldName:
		m.ResetName()
		return nil
	case candidate.FieldDescription:
		m.ResetDescription()
		return nil
	case candidate.FieldPhotoURL:
		m.ResetPhotoURL()
		return nil
	case candidate.FieldVotesCount:
		m.ResetVotesCount()
		return nil
	}
	return fmt.Errorf("unknown Candidate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CandidateMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.election != nil {
		edges = append(edges, candidate.EdgeElection)
	}
	if m.votes != nil {
		edges = append(edges, candidate.EdgeVotes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CandidateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case candidate.EdgeElection:
		if id := m.election; id != nil {
			return []ent.Value{*id}
		}
	case candidate.EdgeVotes:
		ids := make([]ent.Value, 0, len(m.votes))
		for id := range m.votes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CandidateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedvotes != nil {
		edges = append(edges, candidate.EdgeVotes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CandidateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case candidate.EdgeVotes:
		ids := make([]ent.Value, 0, len(m.removedvotes))
		for id := range m.removedvotes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CandidateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedelection {
		edges = append(edges, candidate.EdgeElection)
	}
	if m.clearedvotes {
		edges = append(edges, candidate.EdgeVotes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CandidateMutation) EdgeCleared(name string) bool {
	switch name {
	case candidate.EdgeElection:
		return m.clearedelection
	case candidate.EdgeVotes:
		return m.clearedvotes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CandidateMutation) ClearEdge(name string) error {
	switch name {
	case candidate.EdgeElection:
		m.ClearElection()
		return nil
	}
	return fmt.Errorf("unknown Candidate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CandidateMutation) ResetEdge(name string) error {
	switch name {
	case candidate.EdgeElection:
		m.ResetElection()
		return nil
	case candidate.EdgeVotes:
		m.ResetVotes()
		return nil
	}
	return fmt.Errorf("unknown Candidate edge %s", name)
}

// CommentMutation represents an operation that mutates the Comment nodes in the graph.
type CommentMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	contents        *string
	clearedFields   map[string]struct{}
	parent          *int
	clearedparent   bool
	children        map[int]struct{}
	removedchildren map[int]struct{}
	clearedchildren bool
	user            *int
	cleareduser     bool
	election        *int
	clearedelection bool
	done            bool
	oldValue        func(context.Context) (*Comment, error)
	predicates      []predicate.Comment
}

var _ ent.Mutation = (*CommentMutation)(nil)

// commentOption allows management of the mutation configuration using functional options.
type commentOption func(*CommentMutation)

// newCommentMutation creates new mutation for the Comment entity.
func newCommentMutation(c config, op Op, opts ...commentOption) *CommentMutation {
	m := &CommentMutation{
		config:        c,
		op:            op,
		typ:           TypeComment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCommentID sets the ID field of the mutation.
func withCommentID(id int) commentOption {
	return func(m *CommentMutation) {
		var (
			err   error
			once  sync.Once
			value *Comment
		)
		m.oldValue = func(ctx context.Context) (*Comment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Comment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComment sets the old Comment of the mutation.
func withComment(node *Comment) commentOption {
	return func(m *CommentMutation) {
		m.oldValue = func(context.Context) (*Comment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CommentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CommentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CommentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CommentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Comment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *CommentMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *CommentMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *CommentMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *CommentMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *CommentMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *CommentMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetContents sets the "contents" field.
func (m *CommentMutation) SetContents(s string) {
	m.contents = &s
}

// Contents returns the value of the "contents" field in the mutation.
func (m *CommentMutation) Contents() (r string, exists bool) {
	v := m.contents
	if v == nil {
		return
	}
	return *v, true
}

// OldContents returns the old "contents" field's value of the Comment entity.
// If the Comment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CommentMutation) OldContents(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContents: %w", err)
	}
	return oldValue.Contents, nil
}

// ResetContents resets all changes to the "contents" field.
func (m *CommentMutation) ResetContents() {
	m.contents = nil
}

// SetParentID sets the "parent" edge to the Comment entity by id.
func (m *CommentMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Comment entity.
func (m *CommentMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Comment entity was cleared.
func (m *CommentMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *CommentMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CommentMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Comment entity by ids.
func (m *CommentMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Comment entity.
func (m *CommentMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Comment entity was cleared.
func (m *CommentMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Comment entity by IDs.
func (m *CommentMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Comment entity.
func (m *CommentMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CommentMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CommentMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CommentMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CommentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CommentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CommentMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CommentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetElectionID sets the "election" edge to the Election entity by id.
func (m *CommentMutation) SetElectionID(id int) {
	m.election = &id
}

// ClearElection clears the "election" edge to the Election entity.
func (m *CommentMutation) ClearElection() {
	m.clearedelection = true
}

// ElectionCleared reports if the "election" edge to the Election entity was cleared.
func (m *CommentMutation) ElectionCleared() bool {
	return m.clearedelection
}

// ElectionID returns the "election" edge ID in the mutation.
func (m *CommentMutation) ElectionID() (id int, exists bool) {
	if m.election != nil {
		return *m.election, true
	}
	return
}

// ElectionIDs returns the "election" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ElectionID instead. It exists only for internal usage by the builders.
func (m *CommentMutation) ElectionIDs() (ids []int) {
	if id := m.election; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetElection resets all changes to the "election" edge.
func (m *CommentMutation) ResetElection() {
	m.election = nil
	m.clearedelection = false
}

// Where appends a list predicates to the CommentMutation builder.
func (m *CommentMutation) Where(ps ...predicate.Comment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CommentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CommentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Comment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CommentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CommentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Comment).
func (m *CommentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CommentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.create_time != nil {
		fields = append(fields, comment.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, comment.FieldUpdateTime)
	}
	if m.contents != nil {
		fields = append(fields, comment.FieldContents)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CommentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case comment.FieldCreateTime:
		return m.CreateTime()
	case comment.FieldUpdateTime:
		return m.UpdateTime()
	case comment.FieldContents:
		return m.Contents()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CommentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case comment.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case comment.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case comment.FieldContents:
		return m.OldContents(ctx)
	}
	return nil, fmt.Errorf("unknown Comment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case comment.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case comment.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case comment.FieldContents:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContents(v)
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CommentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CommentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CommentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Comment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CommentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CommentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CommentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Comment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CommentMutation) ResetField(name string) error {
	switch name {
	case comment.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case comment.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case comment.FieldContents:
		m.ResetContents()
		return nil
	}
	return fmt.Errorf("unknown Comment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CommentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, comment.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, comment.EdgeChildren)
	}
	if m.user != nil {
		edges = append(edges, comment.EdgeUser)
	}
	if m.election != nil {
		edges = append(edges, comment.EdgeElection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CommentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case comment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case comment.EdgeElection:
		if id := m.election; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CommentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, comment.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CommentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case comment.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CommentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, comment.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, comment.EdgeChildren)
	}
	if m.cleareduser {
		edges = append(edges, comment.EdgeUser)
	}
	if m.clearedelection {
		edges = append(edges, comment.EdgeElection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CommentMutation) EdgeCleared(name string) bool {
	switch name {
	case comment.EdgeParent:
		return m.clearedparent
	case comment.EdgeChildren:
		return m.clearedchildren
	case comment.EdgeUser:
		return m.cleareduser
	case comment.EdgeElection:
		return m.clearedelection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CommentMutation) ClearEdge(name string) error {
	switch name {
	case comment.EdgeParent:
		m.ClearParent()
		return nil
	case comment.EdgeUser:
		m.ClearUser()
		return nil
	case comment.EdgeElection:
		m.ClearElection()
		return nil
	}
	return fmt.Errorf("unknown Comment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CommentMutation) ResetEdge(name string) error {
	switch name {
	case comment.EdgeParent:
		m.ResetParent()
		return nil
	case comment.EdgeChildren:
		m.ResetChildren()
		return nil
	case comment.EdgeUser:
		m.ResetUser()
		return nil
	case comment.EdgeElection:
		m.ResetElection()
		return nil
	}
	return fmt.Errorf("unknown Comment edge %s", name)
}

// ElectionMutation represents an operation that mutates the Election nodes in the graph.
type ElectionMutation struct {
	config
	op                Op
	typ               string
	id                *int
	title             *string
	description       *string
	clearedFields     map[string]struct{}
	user              *int
	cleareduser       bool
	tags              map[int]struct{}
	removedtags       map[int]struct{}
	clearedtags       bool
	comments          map[int]struct{}
	removedcomments   map[int]struct{}
	clearedcomments   bool
	candidates        map[int]struct{}
	removedcandidates map[int]struct{}
	clearedcandidates bool
	settings          *int
	clearedsettings   bool
	done              bool
	oldValue          func(context.Context) (*Election, error)
	predicates        []predicate.Election
}

var _ ent.Mutation = (*ElectionMutation)(nil)

// electionOption allows management of the mutation configuration using functional options.
type electionOption func(*ElectionMutation)

// newElectionMutation creates new mutation for the Election entity.
func newElectionMutation(c config, op Op, opts ...electionOption) *ElectionMutation {
	m := &ElectionMutation{
		config:        c,
		op:            op,
		typ:           TypeElection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withElectionID sets the ID field of the mutation.
func withElectionID(id int) electionOption {
	return func(m *ElectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Election
		)
		m.oldValue = func(ctx context.Context) (*Election, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Election.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withElection sets the old Election of the mutation.
func withElection(node *Election) electionOption {
	return func(m *ElectionMutation) {
		m.oldValue = func(context.Context) (*Election, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ElectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ElectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ElectionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ElectionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Election.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *ElectionMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ElectionMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Election entity.
// If the Election object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ElectionMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ElectionMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *ElectionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ElectionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Election entity.
// If the Election object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ElectionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ElectionMutation) ResetDescription() {
	m.description = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ElectionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ElectionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ElectionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ElectionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ElectionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ElectionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *ElectionMutation) AddTagIDs(ids ...int) {
	if m.tags == nil {
		m.tags = make(map[int]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *ElectionMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *ElectionMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *ElectionMutation) RemoveTagIDs(ids ...int) {
	if m.removedtags == nil {
		m.removedtags = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *ElectionMutation) RemovedTagsIDs() (ids []int) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *ElectionMutation) TagsIDs() (ids []int) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *ElectionMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *ElectionMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *ElectionMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *ElectionMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *ElectionMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *ElectionMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *ElectionMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *ElectionMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddCandidateIDs adds the "candidates" edge to the Candidate entity by ids.
func (m *ElectionMutation) AddCandidateIDs(ids ...int) {
	if m.candidates == nil {
		m.candidates = make(map[int]struct{})
	}
	for i := range ids {
		m.candidates[ids[i]] = struct{}{}
	}
}

// ClearCandidates clears the "candidates" edge to the Candidate entity.
func (m *ElectionMutation) ClearCandidates() {
	m.clearedcandidates = true
}

// CandidatesCleared reports if the "candidates" edge to the Candidate entity was cleared.
func (m *ElectionMutation) CandidatesCleared() bool {
	return m.clearedcandidates
}

// RemoveCandidateIDs removes the "candidates" edge to the Candidate entity by IDs.
func (m *ElectionMutation) RemoveCandidateIDs(ids ...int) {
	if m.removedcandidates == nil {
		m.removedcandidates = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.candidates, ids[i])
		m.removedcandidates[ids[i]] = struct{}{}
	}
}

// RemovedCandidates returns the removed IDs of the "candidates" edge to the Candidate entity.
func (m *ElectionMutation) RemovedCandidatesIDs() (ids []int) {
	for id := range m.removedcandidates {
		ids = append(ids, id)
	}
	return
}

// CandidatesIDs returns the "candidates" edge IDs in the mutation.
func (m *ElectionMutation) CandidatesIDs() (ids []int) {
	for id := range m.candidates {
		ids = append(ids, id)
	}
	return
}

// ResetCandidates resets all changes to the "candidates" edge.
func (m *ElectionMutation) ResetCandidates() {
	m.candidates = nil
	m.clearedcandidates = false
	m.removedcandidates = nil
}

// SetSettingsID sets the "settings" edge to the ElectionSettings entity by id.
func (m *ElectionMutation) SetSettingsID(id int) {
	m.settings = &id
}

// ClearSettings clears the "settings" edge to the ElectionSettings entity.
func (m *ElectionMutation) ClearSettings() {
	m.clearedsettings = true
}

// SettingsCleared reports if the "settings" edge to the ElectionSettings entity was cleared.
func (m *ElectionMutation) SettingsCleared() bool {
	return m.clearedsettings
}

// SettingsID returns the "settings" edge ID in the mutation.
func (m *ElectionMutation) SettingsID() (id int, exists bool) {
	if m.settings != nil {
		return *m.settings, true
	}
	return
}

// SettingsIDs returns the "settings" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SettingsID instead. It exists only for internal usage by the builders.
func (m *ElectionMutation) SettingsIDs() (ids []int) {
	if id := m.settings; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSettings resets all changes to the "settings" edge.
func (m *ElectionMutation) ResetSettings() {
	m.settings = nil
	m.clearedsettings = false
}

// Where appends a list predicates to the ElectionMutation builder.
func (m *ElectionMutation) Where(ps ...predicate.Election) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ElectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ElectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Election, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ElectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ElectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Election).
func (m *ElectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ElectionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.title != nil {
		fields = append(fields, election.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, election.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ElectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case election.FieldTitle:
		return m.Title()
	case election.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ElectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case election.FieldTitle:
		return m.OldTitle(ctx)
	case election.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Election field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ElectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case election.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case election.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Election field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ElectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ElectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ElectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Election numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ElectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ElectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ElectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Election nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ElectionMutation) ResetField(name string) error {
	switch name {
	case election.FieldTitle:
		m.ResetTitle()
		return nil
	case election.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Election field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ElectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.user != nil {
		edges = append(edges, election.EdgeUser)
	}
	if m.tags != nil {
		edges = append(edges, election.EdgeTags)
	}
	if m.comments != nil {
		edges = append(edges, election.EdgeComments)
	}
	if m.candidates != nil {
		edges = append(edges, election.EdgeCandidates)
	}
	if m.settings != nil {
		edges = append(edges, election.EdgeSettings)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ElectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case election.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case election.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case election.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case election.EdgeCandidates:
		ids := make([]ent.Value, 0, len(m.candidates))
		for id := range m.candidates {
			ids = append(ids, id)
		}
		return ids
	case election.EdgeSettings:
		if id := m.settings; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ElectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtags != nil {
		edges = append(edges, election.EdgeTags)
	}
	if m.removedcomments != nil {
		edges = append(edges, election.EdgeComments)
	}
	if m.removedcandidates != nil {
		edges = append(edges, election.EdgeCandidates)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ElectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case election.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case election.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case election.EdgeCandidates:
		ids := make([]ent.Value, 0, len(m.removedcandidates))
		for id := range m.removedcandidates {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ElectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.cleareduser {
		edges = append(edges, election.EdgeUser)
	}
	if m.clearedtags {
		edges = append(edges, election.EdgeTags)
	}
	if m.clearedcomments {
		edges = append(edges, election.EdgeComments)
	}
	if m.clearedcandidates {
		edges = append(edges, election.EdgeCandidates)
	}
	if m.clearedsettings {
		edges = append(edges, election.EdgeSettings)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ElectionMutation) EdgeCleared(name string) bool {
	switch name {
	case election.EdgeUser:
		return m.cleareduser
	case election.EdgeTags:
		return m.clearedtags
	case election.EdgeComments:
		return m.clearedcomments
	case election.EdgeCandidates:
		return m.clearedcandidates
	case election.EdgeSettings:
		return m.clearedsettings
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ElectionMutation) ClearEdge(name string) error {
	switch name {
	case election.EdgeUser:
		m.ClearUser()
		return nil
	case election.EdgeSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown Election unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ElectionMutation) ResetEdge(name string) error {
	switch name {
	case election.EdgeUser:
		m.ResetUser()
		return nil
	case election.EdgeTags:
		m.ResetTags()
		return nil
	case election.EdgeComments:
		m.ResetComments()
		return nil
	case election.EdgeCandidates:
		m.ResetCandidates()
		return nil
	case election.EdgeSettings:
		m.ResetSettings()
		return nil
	}
	return fmt.Errorf("unknown Election edge %s", name)
}

// ElectionSettingsMutation represents an operation that mutates the ElectionSettings nodes in the graph.
type ElectionSettingsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	is_active       *bool
	is_anonymous    *bool
	allow_comments  *bool
	max_votes       *int
	addmax_votes    *int
	start_date      *time.Time
	end_date        *time.Time
	clearedFields   map[string]struct{}
	election        *int
	clearedelection bool
	done            bool
	oldValue        func(context.Context) (*ElectionSettings, error)
	predicates      []predicate.ElectionSettings
}

var _ ent.Mutation = (*ElectionSettingsMutation)(nil)

// electionsettingsOption allows management of the mutation configuration using functional options.
type electionsettingsOption func(*ElectionSettingsMutation)

// newElectionSettingsMutation creates new mutation for the ElectionSettings entity.
func newElectionSettingsMutation(c config, op Op, opts ...electionsettingsOption) *ElectionSettingsMutation {
	m := &ElectionSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeElectionSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withElectionSettingsID sets the ID field of the mutation.
func withElectionSettingsID(id int) electionsettingsOption {
	return func(m *ElectionSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *ElectionSettings
		)
		m.oldValue = func(ctx context.Context) (*ElectionSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ElectionSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withElectionSettings sets the old ElectionSettings of the mutation.
func withElectionSettings(node *ElectionSettings) electionsettingsOption {
	return func(m *ElectionSettingsMutation) {
		m.oldValue = func(context.Context) (*ElectionSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ElectionSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ElectionSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ElectionSettingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ElectionSettingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ElectionSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsActive sets the "is_active" field.
func (m *ElectionSettingsMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *ElectionSettingsMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the ElectionSettings entity.
// If the ElectionSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ElectionSettingsMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *ElectionSettingsMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsAnonymous sets the "is_anonymous" field.
func (m *ElectionSettingsMutation) SetIsAnonymous(b bool) {
	m.is_anonymous = &b
}

// IsAnonymous returns the value of the "is_anonymous" field in the mutation.
func (m *ElectionSettingsMutation) IsAnonymous() (r bool, exists bool) {
	v := m.is_anonymous
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAnonymous returns the old "is_anonymous" field's value of the ElectionSettings entity.
// If the ElectionSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ElectionSettingsMutation) OldIsAnonymous(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAnonymous is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAnonymous requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAnonymous: %w", err)
	}
	return oldValue.IsAnonymous, nil
}

// ResetIsAnonymous resets all changes to the "is_anonymous" field.
func (m *ElectionSettingsMutation) ResetIsAnonymous() {
	m.is_anonymous = nil
}

// SetAllowComments sets the "allow_comments" field.
func (m *ElectionSettingsMutation) SetAllowComments(b bool) {
	m.allow_comments = &b
}

// AllowComments returns the value of the "allow_comments" field in the mutation.
func (m *ElectionSettingsMutation) AllowComments() (r bool, exists bool) {
	v := m.allow_comments
	if v == nil {
		return
	}
	return *v, true
}

// OldAllowComments returns the old "allow_comments" field's value of the ElectionSettings entity.
// If the ElectionSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ElectionSettingsMutation) OldAllowComments(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllowComments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllowComments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllowComments: %w", err)
	}
	return oldValue.AllowComments, nil
}

// ResetAllowComments resets all changes to the "allow_comments" field.
func (m *ElectionSettingsMutation) ResetAllowComments() {
	m.allow_comments = nil
}

// SetMaxVotes sets the "max_votes" field.
func (m *ElectionSettingsMutation) SetMaxVotes(i int) {
	m.max_votes = &i
	m.addmax_votes = nil
}

// MaxVotes returns the value of the "max_votes" field in the mutation.
func (m *ElectionSettingsMutation) MaxVotes() (r int, exists bool) {
	v := m.max_votes
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxVotes returns the old "max_votes" field's value of the ElectionSettings entity.
// If the ElectionSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ElectionSettingsMutation) OldMaxVotes(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxVotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxVotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxVotes: %w", err)
	}
	return oldValue.MaxVotes, nil
}

// AddMaxVotes adds i to the "max_votes" field.
func (m *ElectionSettingsMutation) AddMaxVotes(i int) {
	if m.addmax_votes != nil {
		*m.addmax_votes += i
	} else {
		m.addmax_votes = &i
	}
}

// AddedMaxVotes returns the value that was added to the "max_votes" field in this mutation.
func (m *ElectionSettingsMutation) AddedMaxVotes() (r int, exists bool) {
	v := m.addmax_votes
	if v == nil {
		return
	}
	return *v, true
}

// ResetMaxVotes resets all changes to the "max_votes" field.
func (m *ElectionSettingsMutation) ResetMaxVotes() {
	m.max_votes = nil
	m.addmax_votes = nil
}

// SetStartDate sets the "start_date" field.
func (m *ElectionSettingsMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ElectionSettingsMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the ElectionSettings entity.
// If the ElectionSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ElectionSettingsMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ElectionSettingsMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *ElectionSettingsMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ElectionSettingsMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the ElectionSettings entity.
// If the ElectionSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ElectionSettingsMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ElectionSettingsMutation) ResetEndDate() {
	m.end_date = nil
}

// SetElectionID sets the "election" edge to the Election entity by id.
func (m *ElectionSettingsMutation) SetElectionID(id int) {
	m.election = &id
}

// ClearElection clears the "election" edge to the Election entity.
func (m *ElectionSettingsMutation) ClearElection() {
	m.clearedelection = true
}

// ElectionCleared reports if the "election" edge to the Election entity was cleared.
func (m *ElectionSettingsMutation) ElectionCleared() bool {
	return m.clearedelection
}

// ElectionID returns the "election" edge ID in the mutation.
func (m *ElectionSettingsMutation) ElectionID() (id int, exists bool) {
	if m.election != nil {
		return *m.election, true
	}
	return
}

// ElectionIDs returns the "election" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ElectionID instead. It exists only for internal usage by the builders.
func (m *ElectionSettingsMutation) ElectionIDs() (ids []int) {
	if id := m.election; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetElection resets all changes to the "election" edge.
func (m *ElectionSettingsMutation) ResetElection() {
	m.election = nil
	m.clearedelection = false
}

// Where appends a list predicates to the ElectionSettingsMutation builder.
func (m *ElectionSettingsMutation) Where(ps ...predicate.ElectionSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ElectionSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ElectionSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ElectionSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ElectionSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ElectionSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ElectionSettings).
func (m *ElectionSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ElectionSettingsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.is_active != nil {
		fields = append(fields, electionsettings.FieldIsActive)
	}
	if m.is_anonymous != nil {
		fields = append(fields, electionsettings.FieldIsAnonymous)
	}
	if m.allow_comments != nil {
		fields = append(fields, electionsettings.FieldAllowComments)
	}
	if m.max_votes != nil {
		fields = append(fields, electionsettings.FieldMaxVotes)
	}
	if m.start_date != nil {
		fields = append(fields, electionsettings.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, electionsettings.FieldEndDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ElectionSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case electionsettings.FieldIsActive:
		return m.IsActive()
	case electionsettings.FieldIsAnonymous:
		return m.IsAnonymous()
	case electionsettings.FieldAllowComments:
		return m.AllowComments()
	case electionsettings.FieldMaxVotes:
		return m.MaxVotes()
	case electionsettings.FieldStartDate:
		return m.StartDate()
	case electionsettings.FieldEndDate:
		return m.EndDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ElectionSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case electionsettings.FieldIsActive:
		return m.OldIsActive(ctx)
	case electionsettings.FieldIsAnonymous:
		return m.OldIsAnonymous(ctx)
	case electionsettings.FieldAllowComments:
		return m.OldAllowComments(ctx)
	case electionsettings.FieldMaxVotes:
		return m.OldMaxVotes(ctx)
	case electionsettings.FieldStartDate:
		return m.OldStartDate(ctx)
	case electionsettings.FieldEndDate:
		return m.OldEndDate(ctx)
	}
	return nil, fmt.Errorf("unknown ElectionSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ElectionSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case electionsettings.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case electionsettings.FieldIsAnonymous:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAnonymous(v)
		return nil
	case electionsettings.FieldAllowComments:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllowComments(v)
		return nil
	case electionsettings.FieldMaxVotes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxVotes(v)
		return nil
	case electionsettings.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case electionsettings.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	}
	return fmt.Errorf("unknown ElectionSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ElectionSettingsMutation) AddedFields() []string {
	var fields []string
	if m.addmax_votes != nil {
		fields = append(fields, electionsettings.FieldMaxVotes)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ElectionSettingsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case electionsettings.FieldMaxVotes:
		return m.AddedMaxVotes()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ElectionSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case electionsettings.FieldMaxVotes:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxVotes(v)
		return nil
	}
	return fmt.Errorf("unknown ElectionSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ElectionSettingsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ElectionSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ElectionSettingsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ElectionSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ElectionSettingsMutation) ResetField(name string) error {
	switch name {
	case electionsettings.FieldIsActive:
		m.ResetIsActive()
		return nil
	case electionsettings.FieldIsAnonymous:
		m.ResetIsAnonymous()
		return nil
	case electionsettings.FieldAllowComments:
		m.ResetAllowComments()
		return nil
	case electionsettings.FieldMaxVotes:
		m.ResetMaxVotes()
		return nil
	case electionsettings.FieldStartDate:
		m.ResetStartDate()
		return nil
	case electionsettings.FieldEndDate:
		m.ResetEndDate()
		return nil
	}
	return fmt.Errorf("unknown ElectionSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ElectionSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.election != nil {
		edges = append(edges, electionsettings.EdgeElection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ElectionSettingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case electionsettings.EdgeElection:
		if id := m.election; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ElectionSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ElectionSettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ElectionSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedelection {
		edges = append(edges, electionsettings.EdgeElection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ElectionSettingsMutation) EdgeCleared(name string) bool {
	switch name {
	case electionsettings.EdgeElection:
		return m.clearedelection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ElectionSettingsMutation) ClearEdge(name string) error {
	switch name {
	case electionsettings.EdgeElection:
		m.ClearElection()
		return nil
	}
	return fmt.Errorf("unknown ElectionSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ElectionSettingsMutation) ResetEdge(name string) error {
	switch name {
	case electionsettings.EdgeElection:
		m.ResetElection()
		return nil
	}
	return fmt.Errorf("unknown ElectionSettings edge %s", name)
}

// ProfileMutation represents an operation that mutates the Profile nodes in the graph.
type ProfileMutation struct {
	config
	op            Op
	typ           string
	id            *int
	first_name    *string
	last_name     *string
	birthdate     *time.Time
	phone_number  *string
	bio           *string
	address       *string
	photo_url     *string
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Profile, error)
	predicates    []predicate.Profile
}

var _ ent.Mutation = (*ProfileMutation)(nil)

// profileOption allows management of the mutation configuration using functional options.
type profileOption func(*ProfileMutation)

// newProfileMutation creates new mutation for the Profile entity.
func newProfileMutation(c config, op Op, opts ...profileOption) *ProfileMutation {
	m := &ProfileMutation{
		config:        c,
		op:            op,
		typ:           TypeProfile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProfileID sets the ID field of the mutation.
func withProfileID(id int) profileOption {
	return func(m *ProfileMutation) {
		var (
			err   error
			once  sync.Once
			value *Profile
		)
		m.oldValue = func(ctx context.Context) (*Profile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Profile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProfile sets the old Profile of the mutation.
func withProfile(node *Profile) profileOption {
	return func(m *ProfileMutation) {
		m.oldValue = func(context.Context) (*Profile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProfileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProfileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProfileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProfileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Profile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirstName sets the "first_name" field.
func (m *ProfileMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *ProfileMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *ProfileMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[profile.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *ProfileMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[profile.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *ProfileMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, profile.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *ProfileMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *ProfileMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *ProfileMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[profile.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *ProfileMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[profile.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *ProfileMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, profile.FieldLastName)
}

// SetBirthdate sets the "birthdate" field.
func (m *ProfileMutation) SetBirthdate(t time.Time) {
	m.birthdate = &t
}

// Birthdate returns the value of the "birthdate" field in the mutation.
func (m *ProfileMutation) Birthdate() (r time.Time, exists bool) {
	v := m.birthdate
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthdate returns the old "birthdate" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldBirthdate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthdate: %w", err)
	}
	return oldValue.Birthdate, nil
}

// ClearBirthdate clears the value of the "birthdate" field.
func (m *ProfileMutation) ClearBirthdate() {
	m.birthdate = nil
	m.clearedFields[profile.FieldBirthdate] = struct{}{}
}

// BirthdateCleared returns if the "birthdate" field was cleared in this mutation.
func (m *ProfileMutation) BirthdateCleared() bool {
	_, ok := m.clearedFields[profile.FieldBirthdate]
	return ok
}

// ResetBirthdate resets all changes to the "birthdate" field.
func (m *ProfileMutation) ResetBirthdate() {
	m.birthdate = nil
	delete(m.clearedFields, profile.FieldBirthdate)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *ProfileMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *ProfileMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *ProfileMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[profile.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *ProfileMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[profile.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *ProfileMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, profile.FieldPhoneNumber)
}

// SetBio sets the "bio" field.
func (m *ProfileMutation) SetBio(s string) {
	m.bio = &s
}

// Bio returns the value of the "bio" field in the mutation.
func (m *ProfileMutation) Bio() (r string, exists bool) {
	v := m.bio
	if v == nil {
		return
	}
	return *v, true
}

// OldBio returns the old "bio" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldBio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBio: %w", err)
	}
	return oldValue.Bio, nil
}

// ClearBio clears the value of the "bio" field.
func (m *ProfileMutation) ClearBio() {
	m.bio = nil
	m.clearedFields[profile.FieldBio] = struct{}{}
}

// BioCleared returns if the "bio" field was cleared in this mutation.
func (m *ProfileMutation) BioCleared() bool {
	_, ok := m.clearedFields[profile.FieldBio]
	return ok
}

// ResetBio resets all changes to the "bio" field.
func (m *ProfileMutation) ResetBio() {
	m.bio = nil
	delete(m.clearedFields, profile.FieldBio)
}

// SetAddress sets the "address" field.
func (m *ProfileMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *ProfileMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *ProfileMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[profile.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *ProfileMutation) AddressCleared() bool {
	_, ok := m.clearedFields[profile.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *ProfileMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, profile.FieldAddress)
}

// SetPhotoURL sets the "photo_url" field.
func (m *ProfileMutation) SetPhotoURL(s string) {
	m.photo_url = &s
}

// PhotoURL returns the value of the "photo_url" field in the mutation.
func (m *ProfileMutation) PhotoURL() (r string, exists bool) {
	v := m.photo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldPhotoURL returns the old "photo_url" field's value of the Profile entity.
// If the Profile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProfileMutation) OldPhotoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhotoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhotoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhotoURL: %w", err)
	}
	return oldValue.PhotoURL, nil
}

// ClearPhotoURL clears the value of the "photo_url" field.
func (m *ProfileMutation) ClearPhotoURL() {
	m.photo_url = nil
	m.clearedFields[profile.FieldPhotoURL] = struct{}{}
}

// PhotoURLCleared returns if the "photo_url" field was cleared in this mutation.
func (m *ProfileMutation) PhotoURLCleared() bool {
	_, ok := m.clearedFields[profile.FieldPhotoURL]
	return ok
}

// ResetPhotoURL resets all changes to the "photo_url" field.
func (m *ProfileMutation) ResetPhotoURL() {
	m.photo_url = nil
	delete(m.clearedFields, profile.FieldPhotoURL)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ProfileMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ProfileMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ProfileMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ProfileMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ProfileMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ProfileMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ProfileMutation builder.
func (m *ProfileMutation) Where(ps ...predicate.Profile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProfileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProfileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Profile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProfileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProfileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Profile).
func (m *ProfileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProfileMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.first_name != nil {
		fields = append(fields, profile.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, profile.FieldLastName)
	}
	if m.birthdate != nil {
		fields = append(fields, profile.FieldBirthdate)
	}
	if m.phone_number != nil {
		fields = append(fields, profile.FieldPhoneNumber)
	}
	if m.bio != nil {
		fields = append(fields, profile.FieldBio)
	}
	if m.address != nil {
		fields = append(fields, profile.FieldAddress)
	}
	if m.photo_url != nil {
		fields = append(fields, profile.FieldPhotoURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProfileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case profile.FieldFirstName:
		return m.FirstName()
	case profile.FieldLastName:
		return m.LastName()
	case profile.FieldBirthdate:
		return m.Birthdate()
	case profile.FieldPhoneNumber:
		return m.PhoneNumber()
	case profile.FieldBio:
		return m.Bio()
	case profile.FieldAddress:
		return m.Address()
	case profile.FieldPhotoURL:
		return m.PhotoURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProfileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case profile.FieldFirstName:
		return m.OldFirstName(ctx)
	case profile.FieldLastName:
		return m.OldLastName(ctx)
	case profile.FieldBirthdate:
		return m.OldBirthdate(ctx)
	case profile.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case profile.FieldBio:
		return m.OldBio(ctx)
	case profile.FieldAddress:
		return m.OldAddress(ctx)
	case profile.FieldPhotoURL:
		return m.OldPhotoURL(ctx)
	}
	return nil, fmt.Errorf("unknown Profile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case profile.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case profile.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case profile.FieldBirthdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthdate(v)
		return nil
	case profile.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case profile.FieldBio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBio(v)
		return nil
	case profile.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case profile.FieldPhotoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhotoURL(v)
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProfileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProfileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProfileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Profile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProfileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(profile.FieldFirstName) {
		fields = append(fields, profile.FieldFirstName)
	}
	if m.FieldCleared(profile.FieldLastName) {
		fields = append(fields, profile.FieldLastName)
	}
	if m.FieldCleared(profile.FieldBirthdate) {
		fields = append(fields, profile.FieldBirthdate)
	}
	if m.FieldCleared(profile.FieldPhoneNumber) {
		fields = append(fields, profile.FieldPhoneNumber)
	}
	if m.FieldCleared(profile.FieldBio) {
		fields = append(fields, profile.FieldBio)
	}
	if m.FieldCleared(profile.FieldAddress) {
		fields = append(fields, profile.FieldAddress)
	}
	if m.FieldCleared(profile.FieldPhotoURL) {
		fields = append(fields, profile.FieldPhotoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProfileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProfileMutation) ClearField(name string) error {
	switch name {
	case profile.FieldFirstName:
		m.ClearFirstName()
		return nil
	case profile.FieldLastName:
		m.ClearLastName()
		return nil
	case profile.FieldBirthdate:
		m.ClearBirthdate()
		return nil
	case profile.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case profile.FieldBio:
		m.ClearBio()
		return nil
	case profile.FieldAddress:
		m.ClearAddress()
		return nil
	case profile.FieldPhotoURL:
		m.ClearPhotoURL()
		return nil
	}
	return fmt.Errorf("unknown Profile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProfileMutation) ResetField(name string) error {
	switch name {
	case profile.FieldFirstName:
		m.ResetFirstName()
		return nil
	case profile.FieldLastName:
		m.ResetLastName()
		return nil
	case profile.FieldBirthdate:
		m.ResetBirthdate()
		return nil
	case profile.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case profile.FieldBio:
		m.ResetBio()
		return nil
	case profile.FieldAddress:
		m.ResetAddress()
		return nil
	case profile.FieldPhotoURL:
		m.ResetPhotoURL()
		return nil
	}
	return fmt.Errorf("unknown Profile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProfileMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, profile.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProfileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case profile.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProfileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProfileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProfileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, profile.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProfileMutation) EdgeCleared(name string) bool {
	switch name {
	case profile.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProfileMutation) ClearEdge(name string) error {
	switch name {
	case profile.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Profile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProfileMutation) ResetEdge(name string) error {
	switch name {
	case profile.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Profile edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	clearedFields    map[string]struct{}
	elections        map[int]struct{}
	removedelections map[int]struct{}
	clearedelections bool
	done             bool
	oldValue         func(context.Context) (*Tag, error)
	predicates       []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// AddElectionIDs adds the "elections" edge to the Election entity by ids.
func (m *TagMutation) AddElectionIDs(ids ...int) {
	if m.elections == nil {
		m.elections = make(map[int]struct{})
	}
	for i := range ids {
		m.elections[ids[i]] = struct{}{}
	}
}

// ClearElections clears the "elections" edge to the Election entity.
func (m *TagMutation) ClearElections() {
	m.clearedelections = true
}

// ElectionsCleared reports if the "elections" edge to the Election entity was cleared.
func (m *TagMutation) ElectionsCleared() bool {
	return m.clearedelections
}

// RemoveElectionIDs removes the "elections" edge to the Election entity by IDs.
func (m *TagMutation) RemoveElectionIDs(ids ...int) {
	if m.removedelections == nil {
		m.removedelections = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.elections, ids[i])
		m.removedelections[ids[i]] = struct{}{}
	}
}

// RemovedElections returns the removed IDs of the "elections" edge to the Election entity.
func (m *TagMutation) RemovedElectionsIDs() (ids []int) {
	for id := range m.removedelections {
		ids = append(ids, id)
	}
	return
}

// ElectionsIDs returns the "elections" edge IDs in the mutation.
func (m *TagMutation) ElectionsIDs() (ids []int) {
	for id := range m.elections {
		ids = append(ids, id)
	}
	return
}

// ResetElections resets all changes to the "elections" edge.
func (m *TagMutation) ResetElections() {
	m.elections = nil
	m.clearedelections = false
	m.removedelections = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.elections != nil {
		edges = append(edges, tag.EdgeElections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeElections:
		ids := make([]ent.Value, 0, len(m.elections))
		for id := range m.elections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedelections != nil {
		edges = append(edges, tag.EdgeElections)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeElections:
		ids := make([]ent.Value, 0, len(m.removedelections))
		for id := range m.removedelections {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedelections {
		edges = append(edges, tag.EdgeElections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeElections:
		return m.clearedelections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeElections:
		m.ResetElections()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op               Op
	typ              string
	id               *int
	create_time      *time.Time
	update_time      *time.Time
	email            *string
	password         *string
	last_login       *time.Time
	is_active        *bool
	is_organizer     *bool
	clearedFields    map[string]struct{}
	profile          *int
	clearedprofile   bool
	comments         map[int]struct{}
	removedcomments  map[int]struct{}
	clearedcomments  bool
	elections        map[int]struct{}
	removedelections map[int]struct{}
	clearedelections bool
	votes            map[int]struct{}
	removedvotes     map[int]struct{}
	clearedvotes     bool
	done             bool
	oldValue         func(context.Context) (*User, error)
	predicates       []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetLastLogin sets the "last_login" field.
func (m *UserMutation) SetLastLogin(t time.Time) {
	m.last_login = &t
}

// LastLogin returns the value of the "last_login" field in the mutation.
func (m *UserMutation) LastLogin() (r time.Time, exists bool) {
	v := m.last_login
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLogin returns the old "last_login" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastLogin(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLogin: %w", err)
	}
	return oldValue.LastLogin, nil
}

// ResetLastLogin resets all changes to the "last_login" field.
func (m *UserMutation) ResetLastLogin() {
	m.last_login = nil
}

// SetIsActive sets the "is_active" field.
func (m *UserMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *UserMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *UserMutation) ResetIsActive() {
	m.is_active = nil
}

// SetIsOrganizer sets the "is_organizer" field.
func (m *UserMutation) SetIsOrganizer(b bool) {
	m.is_organizer = &b
}

// IsOrganizer returns the value of the "is_organizer" field in the mutation.
func (m *UserMutation) IsOrganizer() (r bool, exists bool) {
	v := m.is_organizer
	if v == nil {
		return
	}
	return *v, true
}

// OldIsOrganizer returns the old "is_organizer" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsOrganizer(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsOrganizer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsOrganizer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsOrganizer: %w", err)
	}
	return oldValue.IsOrganizer, nil
}

// ResetIsOrganizer resets all changes to the "is_organizer" field.
func (m *UserMutation) ResetIsOrganizer() {
	m.is_organizer = nil
}

// SetProfileID sets the "profile" edge to the Profile entity by id.
func (m *UserMutation) SetProfileID(id int) {
	m.profile = &id
}

// ClearProfile clears the "profile" edge to the Profile entity.
func (m *UserMutation) ClearProfile() {
	m.clearedprofile = true
}

// ProfileCleared reports if the "profile" edge to the Profile entity was cleared.
func (m *UserMutation) ProfileCleared() bool {
	return m.clearedprofile
}

// ProfileID returns the "profile" edge ID in the mutation.
func (m *UserMutation) ProfileID() (id int, exists bool) {
	if m.profile != nil {
		return *m.profile, true
	}
	return
}

// ProfileIDs returns the "profile" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProfileID instead. It exists only for internal usage by the builders.
func (m *UserMutation) ProfileIDs() (ids []int) {
	if id := m.profile; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProfile resets all changes to the "profile" edge.
func (m *UserMutation) ResetProfile() {
	m.profile = nil
	m.clearedprofile = false
}

// AddCommentIDs adds the "comments" edge to the Comment entity by ids.
func (m *UserMutation) AddCommentIDs(ids ...int) {
	if m.comments == nil {
		m.comments = make(map[int]struct{})
	}
	for i := range ids {
		m.comments[ids[i]] = struct{}{}
	}
}

// ClearComments clears the "comments" edge to the Comment entity.
func (m *UserMutation) ClearComments() {
	m.clearedcomments = true
}

// CommentsCleared reports if the "comments" edge to the Comment entity was cleared.
func (m *UserMutation) CommentsCleared() bool {
	return m.clearedcomments
}

// RemoveCommentIDs removes the "comments" edge to the Comment entity by IDs.
func (m *UserMutation) RemoveCommentIDs(ids ...int) {
	if m.removedcomments == nil {
		m.removedcomments = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.comments, ids[i])
		m.removedcomments[ids[i]] = struct{}{}
	}
}

// RemovedComments returns the removed IDs of the "comments" edge to the Comment entity.
func (m *UserMutation) RemovedCommentsIDs() (ids []int) {
	for id := range m.removedcomments {
		ids = append(ids, id)
	}
	return
}

// CommentsIDs returns the "comments" edge IDs in the mutation.
func (m *UserMutation) CommentsIDs() (ids []int) {
	for id := range m.comments {
		ids = append(ids, id)
	}
	return
}

// ResetComments resets all changes to the "comments" edge.
func (m *UserMutation) ResetComments() {
	m.comments = nil
	m.clearedcomments = false
	m.removedcomments = nil
}

// AddElectionIDs adds the "elections" edge to the Election entity by ids.
func (m *UserMutation) AddElectionIDs(ids ...int) {
	if m.elections == nil {
		m.elections = make(map[int]struct{})
	}
	for i := range ids {
		m.elections[ids[i]] = struct{}{}
	}
}

// ClearElections clears the "elections" edge to the Election entity.
func (m *UserMutation) ClearElections() {
	m.clearedelections = true
}

// ElectionsCleared reports if the "elections" edge to the Election entity was cleared.
func (m *UserMutation) ElectionsCleared() bool {
	return m.clearedelections
}

// RemoveElectionIDs removes the "elections" edge to the Election entity by IDs.
func (m *UserMutation) RemoveElectionIDs(ids ...int) {
	if m.removedelections == nil {
		m.removedelections = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.elections, ids[i])
		m.removedelections[ids[i]] = struct{}{}
	}
}

// RemovedElections returns the removed IDs of the "elections" edge to the Election entity.
func (m *UserMutation) RemovedElectionsIDs() (ids []int) {
	for id := range m.removedelections {
		ids = append(ids, id)
	}
	return
}

// ElectionsIDs returns the "elections" edge IDs in the mutation.
func (m *UserMutation) ElectionsIDs() (ids []int) {
	for id := range m.elections {
		ids = append(ids, id)
	}
	return
}

// ResetElections resets all changes to the "elections" edge.
func (m *UserMutation) ResetElections() {
	m.elections = nil
	m.clearedelections = false
	m.removedelections = nil
}

// AddVoteIDs adds the "votes" edge to the Vote entity by ids.
func (m *UserMutation) AddVoteIDs(ids ...int) {
	if m.votes == nil {
		m.votes = make(map[int]struct{})
	}
	for i := range ids {
		m.votes[ids[i]] = struct{}{}
	}
}

// ClearVotes clears the "votes" edge to the Vote entity.
func (m *UserMutation) ClearVotes() {
	m.clearedvotes = true
}

// VotesCleared reports if the "votes" edge to the Vote entity was cleared.
func (m *UserMutation) VotesCleared() bool {
	return m.clearedvotes
}

// RemoveVoteIDs removes the "votes" edge to the Vote entity by IDs.
func (m *UserMutation) RemoveVoteIDs(ids ...int) {
	if m.removedvotes == nil {
		m.removedvotes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.votes, ids[i])
		m.removedvotes[ids[i]] = struct{}{}
	}
}

// RemovedVotes returns the removed IDs of the "votes" edge to the Vote entity.
func (m *UserMutation) RemovedVotesIDs() (ids []int) {
	for id := range m.removedvotes {
		ids = append(ids, id)
	}
	return
}

// VotesIDs returns the "votes" edge IDs in the mutation.
func (m *UserMutation) VotesIDs() (ids []int) {
	for id := range m.votes {
		ids = append(ids, id)
	}
	return
}

// ResetVotes resets all changes to the "votes" edge.
func (m *UserMutation) ResetVotes() {
	m.votes = nil
	m.clearedvotes = false
	m.removedvotes = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.last_login != nil {
		fields = append(fields, user.FieldLastLogin)
	}
	if m.is_active != nil {
		fields = append(fields, user.FieldIsActive)
	}
	if m.is_organizer != nil {
		fields = append(fields, user.FieldIsOrganizer)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldLastLogin:
		return m.LastLogin()
	case user.FieldIsActive:
		return m.IsActive()
	case user.FieldIsOrganizer:
		return m.IsOrganizer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldLastLogin:
		return m.OldLastLogin(ctx)
	case user.FieldIsActive:
		return m.OldIsActive(ctx)
	case user.FieldIsOrganizer:
		return m.OldIsOrganizer(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldLastLogin:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLogin(v)
		return nil
	case user.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case user.FieldIsOrganizer:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsOrganizer(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldLastLogin:
		m.ResetLastLogin()
		return nil
	case user.FieldIsActive:
		m.ResetIsActive()
		return nil
	case user.FieldIsOrganizer:
		m.ResetIsOrganizer()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.profile != nil {
		edges = append(edges, user.EdgeProfile)
	}
	if m.comments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.elections != nil {
		edges = append(edges, user.EdgeElections)
	}
	if m.votes != nil {
		edges = append(edges, user.EdgeVotes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeProfile:
		if id := m.profile; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.comments))
		for id := range m.comments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeElections:
		ids := make([]ent.Value, 0, len(m.elections))
		for id := range m.elections {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVotes:
		ids := make([]ent.Value, 0, len(m.votes))
		for id := range m.votes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcomments != nil {
		edges = append(edges, user.EdgeComments)
	}
	if m.removedelections != nil {
		edges = append(edges, user.EdgeElections)
	}
	if m.removedvotes != nil {
		edges = append(edges, user.EdgeVotes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeComments:
		ids := make([]ent.Value, 0, len(m.removedcomments))
		for id := range m.removedcomments {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeElections:
		ids := make([]ent.Value, 0, len(m.removedelections))
		for id := range m.removedelections {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeVotes:
		ids := make([]ent.Value, 0, len(m.removedvotes))
		for id := range m.removedvotes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedprofile {
		edges = append(edges, user.EdgeProfile)
	}
	if m.clearedcomments {
		edges = append(edges, user.EdgeComments)
	}
	if m.clearedelections {
		edges = append(edges, user.EdgeElections)
	}
	if m.clearedvotes {
		edges = append(edges, user.EdgeVotes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeProfile:
		return m.clearedprofile
	case user.EdgeComments:
		return m.clearedcomments
	case user.EdgeElections:
		return m.clearedelections
	case user.EdgeVotes:
		return m.clearedvotes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeProfile:
		m.ClearProfile()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeProfile:
		m.ResetProfile()
		return nil
	case user.EdgeComments:
		m.ResetComments()
		return nil
	case user.EdgeElections:
		m.ResetElections()
		return nil
	case user.EdgeVotes:
		m.ResetVotes()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// VoteMutation represents an operation that mutates the Vote nodes in the graph.
type VoteMutation struct {
	config
	op               Op
	typ              string
	id               *int
	create_time      *time.Time
	is_active        *bool
	clearedFields    map[string]struct{}
	candidate        *int
	clearedcandidate bool
	user             *int
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*Vote, error)
	predicates       []predicate.Vote
}

var _ ent.Mutation = (*VoteMutation)(nil)

// voteOption allows management of the mutation configuration using functional options.
type voteOption func(*VoteMutation)

// newVoteMutation creates new mutation for the Vote entity.
func newVoteMutation(c config, op Op, opts ...voteOption) *VoteMutation {
	m := &VoteMutation{
		config:        c,
		op:            op,
		typ:           TypeVote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVoteID sets the ID field of the mutation.
func withVoteID(id int) voteOption {
	return func(m *VoteMutation) {
		var (
			err   error
			once  sync.Once
			value *Vote
		)
		m.oldValue = func(ctx context.Context) (*Vote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVote sets the old Vote of the mutation.
func withVote(node *Vote) voteOption {
	return func(m *VoteMutation) {
		m.oldValue = func(context.Context) (*Vote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("generated: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VoteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VoteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateTime sets the "create_time" field.
func (m *VoteMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *VoteMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *VoteMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetIsActive sets the "is_active" field.
func (m *VoteMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *VoteMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *VoteMutation) ResetIsActive() {
	m.is_active = nil
}

// SetCandidateID sets the "candidate" edge to the Candidate entity by id.
func (m *VoteMutation) SetCandidateID(id int) {
	m.candidate = &id
}

// ClearCandidate clears the "candidate" edge to the Candidate entity.
func (m *VoteMutation) ClearCandidate() {
	m.clearedcandidate = true
}

// CandidateCleared reports if the "candidate" edge to the Candidate entity was cleared.
func (m *VoteMutation) CandidateCleared() bool {
	return m.clearedcandidate
}

// CandidateID returns the "candidate" edge ID in the mutation.
func (m *VoteMutation) CandidateID() (id int, exists bool) {
	if m.candidate != nil {
		return *m.candidate, true
	}
	return
}

// CandidateIDs returns the "candidate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CandidateID instead. It exists only for internal usage by the builders.
func (m *VoteMutation) CandidateIDs() (ids []int) {
	if id := m.candidate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCandidate resets all changes to the "candidate" edge.
func (m *VoteMutation) ResetCandidate() {
	m.candidate = nil
	m.clearedcandidate = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *VoteMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *VoteMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *VoteMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *VoteMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *VoteMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *VoteMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the VoteMutation builder.
func (m *VoteMutation) Where(ps ...predicate.Vote) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Vote, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Vote).
func (m *VoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoteMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.create_time != nil {
		fields = append(fields, vote.FieldCreateTime)
	}
	if m.is_active != nil {
		fields = append(fields, vote.FieldIsActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vote.FieldCreateTime:
		return m.CreateTime()
	case vote.FieldIsActive:
		return m.IsActive()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vote.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case vote.FieldIsActive:
		return m.OldIsActive(ctx)
	}
	return nil, fmt.Errorf("unknown Vote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vote.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case vote.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	}
	return fmt.Errorf("unknown Vote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Vote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Vote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoteMutation) ResetField(name string) error {
	switch name {
	case vote.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case vote.FieldIsActive:
		m.ResetIsActive()
		return nil
	}
	return fmt.Errorf("unknown Vote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.candidate != nil {
		edges = append(edges, vote.EdgeCandidate)
	}
	if m.user != nil {
		edges = append(edges, vote.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vote.EdgeCandidate:
		if id := m.candidate; id != nil {
			return []ent.Value{*id}
		}
	case vote.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcandidate {
		edges = append(edges, vote.EdgeCandidate)
	}
	if m.cleareduser {
		edges = append(edges, vote.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoteMutation) EdgeCleared(name string) bool {
	switch name {
	case vote.EdgeCandidate:
		return m.clearedcandidate
	case vote.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoteMutation) ClearEdge(name string) error {
	switch name {
	case vote.EdgeCandidate:
		m.ClearCandidate()
		return nil
	case vote.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Vote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoteMutation) ResetEdge(name string) error {
	switch name {
	case vote.EdgeCandidate:
		m.ResetCandidate()
		return nil
	case vote.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Vote edge %s", name)
}
